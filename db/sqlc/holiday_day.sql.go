// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: holiday_day.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createHolidayDay = `-- name: CreateHolidayDay :one
INSERT INTO
    "holiday_day" ("date", "holiday_id")
VALUES
    ($1, $2) RETURNING id, date, holiday_id
`

type CreateHolidayDayParams struct {
	Date      pgtype.Date
	HolidayID int32
}

func (q *Queries) CreateHolidayDay(ctx context.Context, arg CreateHolidayDayParams) (HolidayDay, error) {
	row := q.db.QueryRow(ctx, createHolidayDay, arg.Date, arg.HolidayID)
	var i HolidayDay
	err := row.Scan(&i.ID, &i.Date, &i.HolidayID)
	return i, err
}

const deleteHolidayDay = `-- name: DeleteHolidayDay :one
DELETE FROM
    "holiday_day"
WHERE
    "id" = $1 RETURNING id, date, holiday_id
`

func (q *Queries) DeleteHolidayDay(ctx context.Context, id int32) (HolidayDay, error) {
	row := q.db.QueryRow(ctx, deleteHolidayDay, id)
	var i HolidayDay
	err := row.Scan(&i.ID, &i.Date, &i.HolidayID)
	return i, err
}

const queryHolidayDays = `-- name: QueryHolidayDays :many
SELECT
    holiday_day.id, date, holiday_id, holiday.id, name, description, color
FROM
    "holiday_day"
    INNER JOIN "holiday" ON "holiday_day"."holiday_id" = "holiday"."id"
WHERE
    "date" BETWEEN $1 AND $2
    AND (
        $3::integer IS NULL
        OR "holiday_id" = $3
    )
    AND (
        $4::text IS NULL
        OR "holiday"."name" ILIKE '%' || $4 || '%'
    )
    LIMIT $6 OFFSET $5
`

type QueryHolidayDaysParams struct {
	FromDate     pgtype.Date
	ToDate       pgtype.Date
	HolidayID    pgtype.Int4
	HolidayName  pgtype.Text
	OffsetNumber int32
	LimitNumber  int32
}

type QueryHolidayDaysRow struct {
	ID          int32
	Date        pgtype.Date
	HolidayID   int32
	ID_2        int32
	Name        string
	Description pgtype.Text
	Color       pgtype.Text
}

func (q *Queries) QueryHolidayDays(ctx context.Context, arg QueryHolidayDaysParams) ([]QueryHolidayDaysRow, error) {
	rows, err := q.db.Query(ctx, queryHolidayDays,
		arg.FromDate,
		arg.ToDate,
		arg.HolidayID,
		arg.HolidayName,
		arg.OffsetNumber,
		arg.LimitNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryHolidayDaysRow{}
	for rows.Next() {
		var i QueryHolidayDaysRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.HolidayID,
			&i.ID_2,
			&i.Name,
			&i.Description,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
