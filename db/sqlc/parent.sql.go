// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: parent.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countParents = `-- name: CountParents :one
SELECT
    COUNT(*) AS "count"
FROM
    "parent"
WHERE
    (
        $1 :: text IS NULL
        OR "name" ILIKE '%' || $1 || '%'
    )
    AND (
        $2 :: smallint IS NULL
        OR (
            $2 = 1
            AND "user_id" IS NOT NULL
        )
        OR (
            $2 = 0
            AND "user_id" IS NULL
        )
        OR ($2 = -1)
    )
`

type CountParentsParams struct {
	Q       pgtype.Text
	HasUser int16
}

func (q *Queries) CountParents(ctx context.Context, arg CountParentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countParents, arg.Q, arg.HasUser)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createParent = `-- name: CreateParent :one
INSERT INTO
    "parent" (
        "name",
        "address",
        "gender",
        "wa_phone",
        "photo",
        "user_id"
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
    ) RETURNING id, name, address, gender, wa_phone, photo, user_id
`

type CreateParentParams struct {
	Name    string
	Address string
	Gender  Gender
	NoWa    pgtype.Text
	Photo   pgtype.Text
	UserID  pgtype.Int4
}

func (q *Queries) CreateParent(ctx context.Context, arg CreateParentParams) (Parent, error) {
	row := q.db.QueryRow(ctx, createParent,
		arg.Name,
		arg.Address,
		arg.Gender,
		arg.NoWa,
		arg.Photo,
		arg.UserID,
	)
	var i Parent
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Gender,
		&i.WaPhone,
		&i.Photo,
		&i.UserID,
	)
	return i, err
}

const deleteParent = `-- name: DeleteParent :one
DELETE FROM
    "parent"
WHERE
    "id" = $1 RETURNING id, name, address, gender, wa_phone, photo, user_id
`

func (q *Queries) DeleteParent(ctx context.Context, id int32) (Parent, error) {
	row := q.db.QueryRow(ctx, deleteParent, id)
	var i Parent
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Gender,
		&i.WaPhone,
		&i.Photo,
		&i.UserID,
	)
	return i, err
}

const getParent = `-- name: GetParent :one
SELECT
    parent.id, parent.name, parent.address, parent.gender, parent.wa_phone, parent.photo, parent.user_id,
    "user"."id" AS "userId",
    "user"."username" AS "userUsername"
FROM
    "parent"
    LEFT JOIN "user" ON "parent"."user_id" = "user"."id"
WHERE
    "parent"."id" = $1
`

type GetParentRow struct {
	ID           int32
	Name         string
	Address      string
	Gender       Gender
	WaPhone      pgtype.Text
	Photo        pgtype.Text
	UserID       pgtype.Int4
	UserId       pgtype.Int4
	UserUsername pgtype.Text
}

func (q *Queries) GetParent(ctx context.Context, id int32) (GetParentRow, error) {
	row := q.db.QueryRow(ctx, getParent, id)
	var i GetParentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Gender,
		&i.WaPhone,
		&i.Photo,
		&i.UserID,
		&i.UserId,
		&i.UserUsername,
	)
	return i, err
}

const listParentsAsc = `-- name: ListParentsAsc :many
SELECT
    parent.id, parent.name, parent.address, parent.gender, parent.wa_phone, parent.photo, parent.user_id,
    "user"."id" AS "userId",
    "user"."username" AS "userUsername"
FROM
    "parent"
    LEFT JOIN "user" ON "parent"."user_id" = "user"."id"
WHERE
    (
        $1 :: text IS NULL
        OR "name" ILIKE '%' || $1 || '%'
    )
    AND (
        $2 :: smallint IS NULL
        OR (
            $2 = 1
            AND "user_id" IS NOT NULL
        )
        OR (
            $2 = 0
            AND "user_id" IS NULL
        )
        OR ($2 = -1)
    )
ORDER BY
    "name" ASC
LIMIT
    $4 OFFSET $3
`

type ListParentsAscParams struct {
	Q            pgtype.Text
	HasUser      int16
	OffsetNumber int32
	LimitNumber  int32
}

type ListParentsAscRow struct {
	ID           int32
	Name         string
	Address      string
	Gender       Gender
	WaPhone      pgtype.Text
	Photo        pgtype.Text
	UserID       pgtype.Int4
	UserId       pgtype.Int4
	UserUsername pgtype.Text
}

func (q *Queries) ListParentsAsc(ctx context.Context, arg ListParentsAscParams) ([]ListParentsAscRow, error) {
	rows, err := q.db.Query(ctx, listParentsAsc,
		arg.Q,
		arg.HasUser,
		arg.OffsetNumber,
		arg.LimitNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListParentsAscRow{}
	for rows.Next() {
		var i ListParentsAscRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.Gender,
			&i.WaPhone,
			&i.Photo,
			&i.UserID,
			&i.UserId,
			&i.UserUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listParentsDesc = `-- name: ListParentsDesc :many
SELECT
    parent.id, parent.name, parent.address, parent.gender, parent.wa_phone, parent.photo, parent.user_id,
    "user"."id" AS "userId",
    "user"."username" AS "userUsername"
FROM
    "parent"
    LEFT JOIN "user" ON "parent"."user_id" = "user"."id"
WHERE
    (
        $1 :: text IS NULL
        OR "name" ILIKE '%' || $1 || '%'
    )
    AND (
        $2 :: smallint IS NULL
        OR (
            $2 = 1
            AND "user_id" IS NOT NULL
        )
        OR (
            $2 = 0
            AND "user_id" IS NULL
        )
        OR ($2 = -1)
    )
ORDER BY
    "name" ASC
LIMIT
    $4 OFFSET $3
`

type ListParentsDescParams struct {
	Q            pgtype.Text
	HasUser      int16
	OffsetNumber int32
	LimitNumber  int32
}

type ListParentsDescRow struct {
	ID           int32
	Name         string
	Address      string
	Gender       Gender
	WaPhone      pgtype.Text
	Photo        pgtype.Text
	UserID       pgtype.Int4
	UserId       pgtype.Int4
	UserUsername pgtype.Text
}

func (q *Queries) ListParentsDesc(ctx context.Context, arg ListParentsDescParams) ([]ListParentsDescRow, error) {
	rows, err := q.db.Query(ctx, listParentsDesc,
		arg.Q,
		arg.HasUser,
		arg.OffsetNumber,
		arg.LimitNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListParentsDescRow{}
	for rows.Next() {
		var i ListParentsDescRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.Gender,
			&i.WaPhone,
			&i.Photo,
			&i.UserID,
			&i.UserId,
			&i.UserUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateParent = `-- name: UpdateParent :one
UPDATE
    "parent"
SET
    "name" = $1,
    "address" = $2,
    "gender" = $3,
    "wa_phone" = $4,
    "photo" = $5,
    "user_id" = $6
WHERE
    "id" = $7 RETURNING id, name, address, gender, wa_phone, photo, user_id
`

type UpdateParentParams struct {
	Name    string
	Address string
	Gender  Gender
	NoWa    pgtype.Text
	Photo   pgtype.Text
	UserID  pgtype.Int4
	ID      int32
}

func (q *Queries) UpdateParent(ctx context.Context, arg UpdateParentParams) (Parent, error) {
	row := q.db.QueryRow(ctx, updateParent,
		arg.Name,
		arg.Address,
		arg.Gender,
		arg.NoWa,
		arg.Photo,
		arg.UserID,
		arg.ID,
	)
	var i Parent
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.Gender,
		&i.WaPhone,
		&i.Photo,
		&i.UserID,
	)
	return i, err
}
