// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: santri.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSantri = `-- name: CreateSantri :one
INSERT INTO
    "santri" (
        "nis",
        "name",
        "gender",
        "is_active",
        "generation",
        "photo",
        "occupation_id",
        "parent_id"
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6 :: text,
        $7,
        $8
    ) RETURNING id, nis, name, gender, is_active, generation, photo, occupation_id, parent_id
`

type CreateSantriParams struct {
	Nis          pgtype.Text
	Name         string
	Gender       Gender
	IsActive     bool
	Generation   int32
	Photo        pgtype.Text
	OccupationID pgtype.Int4
	ParentID     pgtype.Int4
}

func (q *Queries) CreateSantri(ctx context.Context, arg CreateSantriParams) (Santri, error) {
	row := q.db.QueryRow(ctx, createSantri,
		arg.Nis,
		arg.Name,
		arg.Gender,
		arg.IsActive,
		arg.Generation,
		arg.Photo,
		arg.OccupationID,
		arg.ParentID,
	)
	var i Santri
	err := row.Scan(
		&i.ID,
		&i.Nis,
		&i.Name,
		&i.Gender,
		&i.IsActive,
		&i.Generation,
		&i.Photo,
		&i.OccupationID,
		&i.ParentID,
	)
	return i, err
}

const deleteSantri = `-- name: DeleteSantri :one
DELETE FROM
    "santri"
WHERE
    "id" = $1 RETURNING id, nis, name, gender, is_active, generation, photo, occupation_id, parent_id
`

func (q *Queries) DeleteSantri(ctx context.Context, id int32) (Santri, error) {
	row := q.db.QueryRow(ctx, deleteSantri, id)
	var i Santri
	err := row.Scan(
		&i.ID,
		&i.Nis,
		&i.Name,
		&i.Gender,
		&i.IsActive,
		&i.Generation,
		&i.Photo,
		&i.OccupationID,
		&i.ParentID,
	)
	return i, err
}

const getSantri = `-- name: GetSantri :one
SELECT
    santri.id, santri.nis, santri.name, santri.gender, santri.is_active, santri.generation, santri.photo, santri.occupation_id, santri.parent_id,
    "parent"."id" AS "parentId",
    "parent"."name" AS "parentName",
    "parent"."wa_phone" AS "parentWaPhone",
    "parent"."address" AS "parentAddress",
    "parent"."photo" AS "parentPhoto"
FROM
    "santri"
    LEFT JOIN "parent" ON "santri"."parent_id" = "parent"."id"
    LEFT JOIN "santri_occupation" ON "santri"."occupation_id" = "santri_occupation"."id"
WHERE
    "santri"."id" = $1
`

type GetSantriRow struct {
	ID            int32
	Nis           pgtype.Text
	Name          string
	Gender        Gender
	IsActive      bool
	Generation    int32
	Photo         pgtype.Text
	OccupationID  pgtype.Int4
	ParentID      pgtype.Int4
	ParentId      pgtype.Int4
	ParentName    pgtype.Text
	ParentWaPhone pgtype.Text
	ParentAddress pgtype.Text
	ParentPhoto   pgtype.Text
}

func (q *Queries) GetSantri(ctx context.Context, id int32) (GetSantriRow, error) {
	row := q.db.QueryRow(ctx, getSantri, id)
	var i GetSantriRow
	err := row.Scan(
		&i.ID,
		&i.Nis,
		&i.Name,
		&i.Gender,
		&i.IsActive,
		&i.Generation,
		&i.Photo,
		&i.OccupationID,
		&i.ParentID,
		&i.ParentId,
		&i.ParentName,
		&i.ParentWaPhone,
		&i.ParentAddress,
		&i.ParentPhoto,
	)
	return i, err
}

const querySantriAscGeneration = `-- name: QuerySantriAscGeneration :many
SELECT
    santri.id, santri.nis, santri.name, santri.gender, santri.is_active, santri.generation, santri.photo, santri.occupation_id, santri.parent_id,
    "parent"."id" AS "parentId",
    "parent"."name" AS "parentName",
    "parent"."wa_phone" AS "parentWaPhone",
    "santri_occupation"."id" AS "occupationId",
    "santri_occupation"."name" AS "occupationName"
FROM
    "santri"
    LEFT JOIN "parent" ON "santri"."parent_id" = "parent"."id"
    LEFT JOIN "santri_occupation" ON "santri"."occupation_id" = "santri_occupation"."id"
WHERE
    (
        $1 :: text IS NULL
        OR "santri"."name" ILIKE '%' || $1 || '%'
        OR "santri"."nis" ILIKE '%' || $1 || '%'
    )
    AND (
        $2 :: integer IS NULL
        OR "parent_id" = $2 :: integer
    )
    AND (
        $3 :: integer IS NULL
        OR "occupation_id" = $3 :: integer
    )
    AND (
        $4 :: integer IS NULL
        OR "generation" = $4 :: integer
    )
ORDER BY
    "generation" ASC
LIMIT
    $6 OFFSET $5
`

type QuerySantriAscGenerationParams struct {
	Q            pgtype.Text
	ParentID     pgtype.Int4
	OccupationID pgtype.Int4
	Generation   pgtype.Int4
	OffsetNumber int32
	LimitNumber  int32
}

type QuerySantriAscGenerationRow struct {
	ID             int32
	Nis            pgtype.Text
	Name           string
	Gender         Gender
	IsActive       bool
	Generation     int32
	Photo          pgtype.Text
	OccupationID   pgtype.Int4
	ParentID       pgtype.Int4
	ParentId       pgtype.Int4
	ParentName     pgtype.Text
	ParentWaPhone  pgtype.Text
	OccupationId   pgtype.Int4
	OccupationName pgtype.Text
}

func (q *Queries) QuerySantriAscGeneration(ctx context.Context, arg QuerySantriAscGenerationParams) ([]QuerySantriAscGenerationRow, error) {
	rows, err := q.db.Query(ctx, querySantriAscGeneration,
		arg.Q,
		arg.ParentID,
		arg.OccupationID,
		arg.Generation,
		arg.OffsetNumber,
		arg.LimitNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuerySantriAscGenerationRow{}
	for rows.Next() {
		var i QuerySantriAscGenerationRow
		if err := rows.Scan(
			&i.ID,
			&i.Nis,
			&i.Name,
			&i.Gender,
			&i.IsActive,
			&i.Generation,
			&i.Photo,
			&i.OccupationID,
			&i.ParentID,
			&i.ParentId,
			&i.ParentName,
			&i.ParentWaPhone,
			&i.OccupationId,
			&i.OccupationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const querySantriAscName = `-- name: QuerySantriAscName :many
SELECT
    santri.id, santri.nis, santri.name, santri.gender, santri.is_active, santri.generation, santri.photo, santri.occupation_id, santri.parent_id,
    "parent"."id" AS "parentId",
    "parent"."name" AS "parentName",
    "parent"."wa_phone" AS "parentWaPhone",
    "santri_occupation"."id" AS "occupationId",
    "santri_occupation"."name" AS "occupationName"
FROM
    "santri"
    LEFT JOIN "parent" ON "santri"."parent_id" = "parent"."id"
    LEFT JOIN "santri_occupation" ON "santri"."occupation_id" = "santri_occupation"."id"
WHERE
    (
        $1 :: text IS NULL
        OR "santri"."name" ILIKE '%' || $1 || '%'
        OR "santri"."nis" ILIKE '%' || $1 || '%'
    )
    AND (
        $2 :: integer IS NULL
        OR "parent_id" = $2 :: integer
    )
    AND (
        $3 :: integer IS NULL
        OR "occupation_id" = $3 :: integer
    )
    AND (
        $4 :: integer IS NULL
        OR "generation" = $4 :: integer
    )
ORDER BY
    "santri"."name" ASC
LIMIT
    $6 OFFSET $5
`

type QuerySantriAscNameParams struct {
	Q            pgtype.Text
	ParentID     pgtype.Int4
	OccupationID pgtype.Int4
	Generation   pgtype.Int4
	OffsetNumber int32
	LimitNumber  int32
}

type QuerySantriAscNameRow struct {
	ID             int32
	Nis            pgtype.Text
	Name           string
	Gender         Gender
	IsActive       bool
	Generation     int32
	Photo          pgtype.Text
	OccupationID   pgtype.Int4
	ParentID       pgtype.Int4
	ParentId       pgtype.Int4
	ParentName     pgtype.Text
	ParentWaPhone  pgtype.Text
	OccupationId   pgtype.Int4
	OccupationName pgtype.Text
}

func (q *Queries) QuerySantriAscName(ctx context.Context, arg QuerySantriAscNameParams) ([]QuerySantriAscNameRow, error) {
	rows, err := q.db.Query(ctx, querySantriAscName,
		arg.Q,
		arg.ParentID,
		arg.OccupationID,
		arg.Generation,
		arg.OffsetNumber,
		arg.LimitNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuerySantriAscNameRow{}
	for rows.Next() {
		var i QuerySantriAscNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Nis,
			&i.Name,
			&i.Gender,
			&i.IsActive,
			&i.Generation,
			&i.Photo,
			&i.OccupationID,
			&i.ParentID,
			&i.ParentId,
			&i.ParentName,
			&i.ParentWaPhone,
			&i.OccupationId,
			&i.OccupationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const querySantriAscNis = `-- name: QuerySantriAscNis :many
SELECT
    santri.id, santri.nis, santri.name, santri.gender, santri.is_active, santri.generation, santri.photo, santri.occupation_id, santri.parent_id,
    "parent"."id" AS "parentId",
    "parent"."name" AS "parentName",
    "parent"."wa_phone" AS "parentWaPhone",
    "santri_occupation"."id" AS "occupationId",
    "santri_occupation"."name" AS "occupationName"
FROM
    "santri"
    LEFT JOIN "parent" ON "santri"."parent_id" = "parent"."id"
    LEFT JOIN "santri_occupation" ON "santri"."occupation_id" = "santri_occupation"."id"
WHERE
    (
        $1 :: text IS NULL
        OR "santri"."name" ILIKE '%' || $1 || '%'
        OR "santri"."nis" ILIKE '%' || $1 || '%'
    )
    AND (
        $2 :: integer IS NULL
        OR "parent_id" = $2 :: integer
    )
    AND (
        $3 :: integer IS NULL
        OR "occupation_id" = $3 :: integer
    )
    AND (
        $4 :: integer IS NULL
        OR "generation" = $4 :: integer
    )
ORDER BY
    "nis" ASC
LIMIT
    $6 OFFSET $5
`

type QuerySantriAscNisParams struct {
	Q            pgtype.Text
	ParentID     pgtype.Int4
	OccupationID pgtype.Int4
	Generation   pgtype.Int4
	OffsetNumber int32
	LimitNumber  int32
}

type QuerySantriAscNisRow struct {
	ID             int32
	Nis            pgtype.Text
	Name           string
	Gender         Gender
	IsActive       bool
	Generation     int32
	Photo          pgtype.Text
	OccupationID   pgtype.Int4
	ParentID       pgtype.Int4
	ParentId       pgtype.Int4
	ParentName     pgtype.Text
	ParentWaPhone  pgtype.Text
	OccupationId   pgtype.Int4
	OccupationName pgtype.Text
}

func (q *Queries) QuerySantriAscNis(ctx context.Context, arg QuerySantriAscNisParams) ([]QuerySantriAscNisRow, error) {
	rows, err := q.db.Query(ctx, querySantriAscNis,
		arg.Q,
		arg.ParentID,
		arg.OccupationID,
		arg.Generation,
		arg.OffsetNumber,
		arg.LimitNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuerySantriAscNisRow{}
	for rows.Next() {
		var i QuerySantriAscNisRow
		if err := rows.Scan(
			&i.ID,
			&i.Nis,
			&i.Name,
			&i.Gender,
			&i.IsActive,
			&i.Generation,
			&i.Photo,
			&i.OccupationID,
			&i.ParentID,
			&i.ParentId,
			&i.ParentName,
			&i.ParentWaPhone,
			&i.OccupationId,
			&i.OccupationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const querySantriAscOccupation = `-- name: QuerySantriAscOccupation :many
SELECT
    santri.id, santri.nis, santri.name, santri.gender, santri.is_active, santri.generation, santri.photo, santri.occupation_id, santri.parent_id,
    "parent"."id" AS "parentId",
    "parent"."name" AS "parentName",
    "parent"."wa_phone" AS "parentWaPhone",
    "santri_occupation"."id" AS "occupationId",
    "santri_occupation"."name" AS "occupationName"
FROM
    "santri"
    LEFT JOIN "parent" ON "santri"."parent_id" = "parent"."id"
    LEFT JOIN "santri_occupation" ON "santri"."occupation_id" = "santri_occupation"."id"
WHERE
    (
        $1 :: text IS NULL
        OR "santri"."name" ILIKE '%' || $1 || '%'
        OR "santri"."nis" ILIKE '%' || $1 || '%'
    )
    AND (
        $2 :: integer IS NULL
        OR "parent_id" = $2 :: integer
    )
    AND (
        $3 :: integer IS NULL
        OR "occupation_id" = $3 :: integer
    )
    AND (
        $4 :: integer IS NULL
        OR "generation" = $4 :: integer
    )
ORDER BY
    "occupation_id" ASC
LIMIT
    $6 OFFSET $5
`

type QuerySantriAscOccupationParams struct {
	Q            pgtype.Text
	ParentID     pgtype.Int4
	OccupationID pgtype.Int4
	Generation   pgtype.Int4
	OffsetNumber int32
	LimitNumber  int32
}

type QuerySantriAscOccupationRow struct {
	ID             int32
	Nis            pgtype.Text
	Name           string
	Gender         Gender
	IsActive       bool
	Generation     int32
	Photo          pgtype.Text
	OccupationID   pgtype.Int4
	ParentID       pgtype.Int4
	ParentId       pgtype.Int4
	ParentName     pgtype.Text
	ParentWaPhone  pgtype.Text
	OccupationId   pgtype.Int4
	OccupationName pgtype.Text
}

func (q *Queries) QuerySantriAscOccupation(ctx context.Context, arg QuerySantriAscOccupationParams) ([]QuerySantriAscOccupationRow, error) {
	rows, err := q.db.Query(ctx, querySantriAscOccupation,
		arg.Q,
		arg.ParentID,
		arg.OccupationID,
		arg.Generation,
		arg.OffsetNumber,
		arg.LimitNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuerySantriAscOccupationRow{}
	for rows.Next() {
		var i QuerySantriAscOccupationRow
		if err := rows.Scan(
			&i.ID,
			&i.Nis,
			&i.Name,
			&i.Gender,
			&i.IsActive,
			&i.Generation,
			&i.Photo,
			&i.OccupationID,
			&i.ParentID,
			&i.ParentId,
			&i.ParentName,
			&i.ParentWaPhone,
			&i.OccupationId,
			&i.OccupationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSantri = `-- name: UpdateSantri :one
UPDATE
    "santri"
SET
    "nis" = $1,
    "name" = $2,
    "generation" = $3,
    "is_active" = $4 :: boolean,
    "photo" = $5 :: text,
    "occupation_id" = $6,
    "parent_id" = $7 :: integer
WHERE
    "id" = $8 RETURNING id, nis, name, gender, is_active, generation, photo, occupation_id, parent_id
`

type UpdateSantriParams struct {
	Nis          pgtype.Text
	Name         string
	Generation   int32
	IsActive     bool
	Photo        pgtype.Text
	OccupationID pgtype.Int4
	ParentID     pgtype.Int4
	ID           int32
}

func (q *Queries) UpdateSantri(ctx context.Context, arg UpdateSantriParams) (Santri, error) {
	row := q.db.QueryRow(ctx, updateSantri,
		arg.Nis,
		arg.Name,
		arg.Generation,
		arg.IsActive,
		arg.Photo,
		arg.OccupationID,
		arg.ParentID,
		arg.ID,
	)
	var i Santri
	err := row.Scan(
		&i.ID,
		&i.Nis,
		&i.Name,
		&i.Gender,
		&i.IsActive,
		&i.Generation,
		&i.Photo,
		&i.OccupationID,
		&i.ParentID,
	)
	return i, err
}
