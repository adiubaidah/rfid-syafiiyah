// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: rfid.sql

package persistence

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRfid = `-- name: CreateRfid :one
INSERT INTO
    rfid ("uid", "is_active", "santri_id", "employee_id")
VALUES
    (
        $1,
        $2,
        $3,
        $4
    ) RETURNING id, uid, created_at, is_active, santri_id, employee_id
`

type CreateRfidParams struct {
	Uid        string      `db:"uid"`
	IsActive   bool        `db:"is_active"`
	SantriID   pgtype.Int4 `db:"santri_id"`
	EmployeeID pgtype.Int4 `db:"employee_id"`
}

func (q *Queries) CreateRfid(ctx context.Context, arg CreateRfidParams) (Rfid, error) {
	row := q.db.QueryRow(ctx, createRfid,
		arg.Uid,
		arg.IsActive,
		arg.SantriID,
		arg.EmployeeID,
	)
	var i Rfid
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.CreatedAt,
		&i.IsActive,
		&i.SantriID,
		&i.EmployeeID,
	)
	return i, err
}

const deleteRfid = `-- name: DeleteRfid :one
DELETE FROM
    rfid
WHERE
    "id" = $1 RETURNING id, uid, created_at, is_active, santri_id, employee_id
`

func (q *Queries) DeleteRfid(ctx context.Context, id int32) (Rfid, error) {
	row := q.db.QueryRow(ctx, deleteRfid, id)
	var i Rfid
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.CreatedAt,
		&i.IsActive,
		&i.SantriID,
		&i.EmployeeID,
	)
	return i, err
}

const getRfidById = `-- name: GetRfidById :one
SELECT
    rfid.id, rfid.uid, rfid.created_at, rfid.is_active, rfid.santri_id, rfid.employee_id,
    "santri"."name" as "santri_name",
    "employee"."name" as "employee_name"
FROM
    rfid
    LEFT JOIN "santri" ON "rfid"."santri_id" = "santri"."id"
    LEFT JOIN "employee" ON "rfid"."employee_id" = "employee"."id"
WHERE
    "rfid"."id" = $1
`

type GetRfidByIdRow struct {
	ID           int32              `db:"id"`
	Uid          string             `db:"uid"`
	CreatedAt    pgtype.Timestamptz `db:"created_at"`
	IsActive     bool               `db:"is_active"`
	SantriID     pgtype.Int4        `db:"santri_id"`
	EmployeeID   pgtype.Int4        `db:"employee_id"`
	SantriName   pgtype.Text        `db:"santri_name"`
	EmployeeName pgtype.Text        `db:"employee_name"`
}

func (q *Queries) GetRfidById(ctx context.Context, id int32) (GetRfidByIdRow, error) {
	row := q.db.QueryRow(ctx, getRfidById, id)
	var i GetRfidByIdRow
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.CreatedAt,
		&i.IsActive,
		&i.SantriID,
		&i.EmployeeID,
		&i.SantriName,
		&i.EmployeeName,
	)
	return i, err
}

const listRfid = `-- name: ListRfid :many
SELECT
    rfid.id, rfid.uid, rfid.created_at, rfid.is_active, rfid.santri_id, rfid.employee_id,
    "santri"."name" as "santri_name",
    "employee"."name" as "employee_name"
FROM
    rfid
    LEFT JOIN "santri" ON "rfid"."santri_id" = "santri"."id"
    LEFT JOIN "employee" ON "rfid"."employee_id" = "employee"."id"
WHERE
    (
        $1 :: text IS NULL
        OR "uid" ILIKE '%' || $1 || '%'
        OR "santri"."name" ILIKE '%' || $1 || '%'
        OR "employee"."name" ILIKE '%' || $1 || '%'
    )
    AND (
        $2::boolean IS NULL
        OR "rfid"."is_active" = $2
    )
    AND (
        (
            $3::boolean IS NULL
            OR $3 = FALSE
        )
        AND "rfid"."santri_id" IS NULL
        OR $3 = TRUE
    )
    AND (
        (
            $4::boolean IS NULL
            OR $4 = FALSE
        )
        AND "rfid"."employee_id" IS NULL
        OR $4 = TRUE
    )
ORDER BY
    "rfid"."id" ASC
LIMIT
    $6 OFFSET $5
`

type ListRfidParams struct {
	Q            pgtype.Text `db:"q"`
	IsActive     pgtype.Bool `db:"is_active"`
	IsSantri     pgtype.Bool `db:"is_santri"`
	IsEmployee   pgtype.Bool `db:"is_employee"`
	OffsetNumber int32       `db:"offset_number"`
	LimitNumber  int32       `db:"limit_number"`
}

type ListRfidRow struct {
	ID           int32              `db:"id"`
	Uid          string             `db:"uid"`
	CreatedAt    pgtype.Timestamptz `db:"created_at"`
	IsActive     bool               `db:"is_active"`
	SantriID     pgtype.Int4        `db:"santri_id"`
	EmployeeID   pgtype.Int4        `db:"employee_id"`
	SantriName   pgtype.Text        `db:"santri_name"`
	EmployeeName pgtype.Text        `db:"employee_name"`
}

func (q *Queries) ListRfid(ctx context.Context, arg ListRfidParams) ([]ListRfidRow, error) {
	rows, err := q.db.Query(ctx, listRfid,
		arg.Q,
		arg.IsActive,
		arg.IsSantri,
		arg.IsEmployee,
		arg.OffsetNumber,
		arg.LimitNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRfidRow{}
	for rows.Next() {
		var i ListRfidRow
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.CreatedAt,
			&i.IsActive,
			&i.SantriID,
			&i.EmployeeID,
			&i.SantriName,
			&i.EmployeeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRfid = `-- name: UpdateRfid :one
UPDATE
    rfid
SET
    "uid" = COALESCE($1, uid),
    "is_active" = COALESCE($2, is_active),
    "santri_id" = $3,
    "employee_id" = $4
WHERE
    "id" = $5 RETURNING id, uid, created_at, is_active, santri_id, employee_id
`

type UpdateRfidParams struct {
	Uid        pgtype.Text `db:"uid"`
	IsActive   pgtype.Bool `db:"is_active"`
	SantriID   pgtype.Int4 `db:"santri_id"`
	EmployeeID pgtype.Int4 `db:"employee_id"`
	ID         int32       `db:"id"`
}

func (q *Queries) UpdateRfid(ctx context.Context, arg UpdateRfidParams) (Rfid, error) {
	row := q.db.QueryRow(ctx, updateRfid,
		arg.Uid,
		arg.IsActive,
		arg.SantriID,
		arg.EmployeeID,
		arg.ID,
	)
	var i Rfid
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.CreatedAt,
		&i.IsActive,
		&i.SantriID,
		&i.EmployeeID,
	)
	return i, err
}
