// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: employee.sql

package persistence

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO
    "employee" (
        "nip",
        "name",
        "gender",
        "photo",
        "occupation_id",
        "user_id"
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4::text,
        $5,
        $6::integer
    ) RETURNING id, nip, name, gender, photo, occupation_id, user_id
`

type CreateEmployeeParams struct {
	Nip          pgtype.Text `db:"nip"`
	Name         string      `db:"name"`
	Gender       Gender      `db:"gender"`
	Photo        pgtype.Text `db:"photo"`
	OccupationID int32       `db:"occupation_id"`
	UserID       pgtype.Int4 `db:"user_id"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, createEmployee,
		arg.Nip,
		arg.Name,
		arg.Gender,
		arg.Photo,
		arg.OccupationID,
		arg.UserID,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Nip,
		&i.Name,
		&i.Gender,
		&i.Photo,
		&i.OccupationID,
		&i.UserID,
	)
	return i, err
}

const deleteEmployee = `-- name: DeleteEmployee :one
DELETE FROM
    "employee"
WHERE
    "id" = $1
RETURNING id, nip, name, gender, photo, occupation_id, user_id
`

func (q *Queries) DeleteEmployee(ctx context.Context, id int32) (Employee, error) {
	row := q.db.QueryRow(ctx, deleteEmployee, id)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Nip,
		&i.Name,
		&i.Gender,
		&i.Photo,
		&i.OccupationID,
		&i.UserID,
	)
	return i, err
}

const getEmployee = `-- name: GetEmployee :one
SELECT
    employee.id, employee.nip, employee.name, employee.gender, employee.photo, employee.occupation_id, employee.user_id,
    "user"."id" AS "userId",
    "user"."username" AS "userUsername"
FROM
    "employee"
    LEFT JOIN "user" ON "employee"."user_id" = "user"."id"
WHERE
    "employee"."id" = $1
`

type GetEmployeeRow struct {
	ID           int32       `db:"id"`
	Nip          pgtype.Text `db:"nip"`
	Name         string      `db:"name"`
	Gender       Gender      `db:"gender"`
	Photo        pgtype.Text `db:"photo"`
	OccupationID int32       `db:"occupation_id"`
	UserID       pgtype.Int4 `db:"user_id"`
	UserId       pgtype.Int4 `db:"userId"`
	UserUsername pgtype.Text `db:"userUsername"`
}

func (q *Queries) GetEmployee(ctx context.Context, id int32) (GetEmployeeRow, error) {
	row := q.db.QueryRow(ctx, getEmployee, id)
	var i GetEmployeeRow
	err := row.Scan(
		&i.ID,
		&i.Nip,
		&i.Name,
		&i.Gender,
		&i.Photo,
		&i.OccupationID,
		&i.UserID,
		&i.UserId,
		&i.UserUsername,
	)
	return i, err
}

const listEmployeesAsc = `-- name: ListEmployeesAsc :many
SELECT
    employee.id, employee.nip, employee.name, employee.gender, employee.photo, employee.occupation_id, employee.user_id,
    "user"."id" AS "userId",
    "user"."username" AS "userUsername"
FROM
    "employee"
    LEFT JOIN "user" ON "employee"."user_id" = "user"."id"
WHERE
    (
        $1::text IS NULL
        OR "name" ILIKE '%' || $1 || '%'
    )
    AND (
        $2 :: smallint IS NULL
        OR (
            $2 = 1
            AND "user_id" IS NOT NULL
        )
        OR (
            $2 = 0
            AND "user_id" IS NULL
        )
        OR ($2 = -1)
    )
ORDER BY
    "name" ASC
LIMIT
    $4 OFFSET $3
`

type ListEmployeesAscParams struct {
	Q            pgtype.Text `db:"q"`
	HasUser      int16       `db:"has_user"`
	OffsetNumber int32       `db:"offset_number"`
	LimitNumber  int32       `db:"limit_number"`
}

type ListEmployeesAscRow struct {
	ID           int32       `db:"id"`
	Nip          pgtype.Text `db:"nip"`
	Name         string      `db:"name"`
	Gender       Gender      `db:"gender"`
	Photo        pgtype.Text `db:"photo"`
	OccupationID int32       `db:"occupation_id"`
	UserID       pgtype.Int4 `db:"user_id"`
	UserId       pgtype.Int4 `db:"userId"`
	UserUsername pgtype.Text `db:"userUsername"`
}

func (q *Queries) ListEmployeesAsc(ctx context.Context, arg ListEmployeesAscParams) ([]ListEmployeesAscRow, error) {
	rows, err := q.db.Query(ctx, listEmployeesAsc,
		arg.Q,
		arg.HasUser,
		arg.OffsetNumber,
		arg.LimitNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEmployeesAscRow{}
	for rows.Next() {
		var i ListEmployeesAscRow
		if err := rows.Scan(
			&i.ID,
			&i.Nip,
			&i.Name,
			&i.Gender,
			&i.Photo,
			&i.OccupationID,
			&i.UserID,
			&i.UserId,
			&i.UserUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmployee = `-- name: UpdateEmployee :one
UPDATE
    "employee"
SET
    "nip" = $1,
    "name" = $2,
    "gender" = $3,
    "photo" = $4,
    "occupation_id" = $5,
    "user_id" = $6
WHERE
    "id" = $7 RETURNING id, nip, name, gender, photo, occupation_id, user_id
`

type UpdateEmployeeParams struct {
	Nip          pgtype.Text `db:"nip"`
	Name         string      `db:"name"`
	Gender       Gender      `db:"gender"`
	Photo        pgtype.Text `db:"photo"`
	OccupationID int32       `db:"occupation_id"`
	UserID       pgtype.Int4 `db:"user_id"`
	ID           int32       `db:"id"`
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) (Employee, error) {
	row := q.db.QueryRow(ctx, updateEmployee,
		arg.Nip,
		arg.Name,
		arg.Gender,
		arg.Photo,
		arg.OccupationID,
		arg.UserID,
		arg.ID,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Nip,
		&i.Name,
		&i.Gender,
		&i.Photo,
		&i.OccupationID,
		&i.UserID,
	)
	return i, err
}
